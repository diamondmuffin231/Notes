
# Android Studio Basics 
●/○/◼️/◻️/◆/◇/▲/△ ✔

9.6.2025
● App Manifest/AndroidManifest file
● Add Folder /App Architecture or /App Component 
	○ Add File that exmaplains (App Component Stuff)
	○ Keep Basic Idea on this file (for refrence) 
● Study Layout subject  
● Database 
	○ SQLite (Structured Query Language) & Room (library) 
	○ Creating a database 
		1. Create a DB folder 
		2. Add Dependencies
		3a. Entity
		3b. DAO
		3c. Database Class
		4. Using the database 
		5. Layout File (optional for different UI?)

***********************************************************
***********************************************************
***********************************************************
 
***********************************************************
***********************************************************
***********************************************************
						General 
● Modules 
● Project Files 	
● App Architecture 
	○ App Components 
		◼️ App Components typically include :
		◼️ Declaring an App Component
		◼️ Manage dependencies between components 
● Activities
● Fragments 
● App Manifest (File)
● Layout 

***********************************************************
***********************************************************
***********************************************************

						Modules 

● Intro to Modules 
A module is a collection of source files/code and build settings 
that let you divide your project into discrete units of functionality.
Each module can be independently built, tested, and debugged.
Note that you might hear modules referred to as "projects" or 
"subprojects" in Gradle documentation.
	
Android Studio uses modules to make it easy to add new devices to your 
project, but keep all the files scoped within the same project and share
some code.Also when creating code libraries within your own project.
	
● Types of modules 
	○ Android app module
	Provides a container for your app's source code, resource files, 
	and app-level settings, such as the module-level build file and
	Android Manifest file. When you create a new project, the default 
	app module is named "app." Each module provides essential files 
	and some code templates that are appropriate for the corresponding 
	app or device type.

	○ Feature module 
	Represents a modularized feature of your app that can take advantage 
	of Play Feature Delivery.
		
	○ Library module 
	Provides a container for your reusable code, which you can use as a 
	dependency in other app modules or import into other projects. 
	Structurally, a library module is the same as an app module, 
	but when built, it creates a code archive file instead of an APK, 
	so it can't be installed on a device.
			
		◼️ Types of library modules :
		◼️ Android Library 
		◼️ Android Native Library 
		◼️ Java or Kotlin Library 
		◼️ Benchmark > Microbenchmark 
				
		
		○ Test module 
			Keeps your tests separate from the rest of your code. You can 
			configure the test module to target specific build variants.
			
			Types of test modules :
				◼️ Baseline Profile Generator 
				◼️ Benchmark > Macrobenchmark 
			


***********************************************************
***********************************************************
***********************************************************

Project Files 

	● Intro to Project Files 
	Files in Android Studio can be found in the Project View Selector (or 
	View Mode Selector). The Project View Selector has files in categories 
	called Project-View-Modes (or Scoopes/View-Presets). 
	
	This view doesn't reflect the actual file hierarchy on disk. Instead, 
	it's organized by modules and file types. 
	
	The Android view
		Some of the structural differences between the Android view and the 
		structure on disk :
			○ Gradle Script group
				A build system transforms your source code into an executable 
				application. Gradle uses a task-based approach to organize and 
				run these commands.
			○ A group with all manifestfiles for each module. 
			○ Alternative resource files in a single group instead of in seperate 
			folders.
		  
		Within each Android app module, files are shown in the following groups:
			○ manifests : Contains the "AndroidManifest.xml" file.
			○ java (or Kotlin/Groovy?)
			○ res 

	
	The Project view 

***********************************************************
***********************************************************
***********************************************************

App Architecture

	● App Component (General)
	A typical Android app contains multiple app components. You 
	declare most of these app components in your app manifest. Given 
 	the conditions of this environment, it's possible for your app 
    components to be launched individually and out-of-order, and the 
	operating system or user can destroy them at any time. 
		○ App Components typically include :
			◼️ Activity, Fragment, 
			◼️ Drive UI from data models
			◼️ SSOT (Single source of truth)
			◼️ Unidirectional Data Flow 

		○ Declaring an App Component 
			◼️ "Android Manifest"
			   The "Android Manifest" is the general term for the manifest file 
 			   in any Android component. Not to be confused with the "App Manifest" 
			   which specifically refers to the manifest in the main app module 
			   (app/src/main/AndroidManifest.xml) 
			  
		
	
	● Recommended app architecture 
		○ General 
			Each application should have at least two layers. An additional layer 
		    can be added called the domain layer to simplify and reuse the interactions
		    between the UI and data layers. 
				1) UI Layer 
				x) Domain Layer (optional)
				2) Data Layer 
		○ Modern App Architecture 
			This Modern App Architecture encourages using the following 
			techniques, among others:
		○ UI layer 
		○ Data layer 
			The data layer of an app contains the business logic, it's made of 
			rules that determine how your app creates, stores, and changes data.
			
			 Repository 
				The data layer is made of repositories that each can contain 
				zero to many data sources.  You should create a repository class
				for each different type of data you handle in your app.
				
				Repository classes are responsible for the following tasks:
					- Exposing data to the rest of the app.
					- Centralizing changes to the data.
					- Resolving conflicts between multiple data sources.
					- Abstracting sources of data from the rest of the app.
					- Containing business logic.
				
				▲ Data Source (classes)
					Each data source class should have the responsibility of work-
					ing with only one source of data, which can be a file, a netwo-
					rk source, or a local database. 
    ??? Domain Layer 
	
	● Manage dependencies between components 
		○ Classes in your app depend on other classes in order to function properly. 
		  You can use either "Dependency injection (DI)" or "Service locator". 
		  These patterns allow you to scale your code because they provide clear 
		  patterns for managing dependencies without duplicating code or adding 
		  complexity. Furthermore, these patterns allow you to quickly switch 
		  between test and production implementations.
		
***********************************************************
***********************************************************
***********************************************************

***********************************************************
***********************************************************
***********************************************************

Activities 
		
	● Main Activity 
		○ Main activity 
			◼️ The main activity source code is found in the MainActivity.kt file.
				◻️ ProjectName/app/src/main/java/com/example/project_name/MainActivity.kt 
			◼️ The main activity like all other actitvies is declared in in the manifest file. 
				
	● Activities Basics/General 
		○ Declaring activities 
			◼️ For your app to be able to use activities, you must declare the 
				activities, and certain of their attributes, in the manifest.
				
			◼️ The manifest file describes essential information about your app 
			to the Android build tools, the Android operating system, and 
			Google Play. 
				
				◻️ The manifest file is named AndroidManifest.xml.
					app/src/main/AndroidManifest.xml
					
				◻️ The main activity like all other actitvies is declared in 
					in the manifest file. 
					
			◼️ To declare your activity, open your manifest file and add 
				an <activity> element as a child of the <application> element. 
		
		○ Intent filters 
		
			◼️ General 
			Intent filters provide the ability to launch an activity based 
			not only on an explicit request, but also an implicit one. 
				
			If you intend for your app to be self-contained and not allow 
			other apps to activate its activities, you don't need any 
			other intent filters. Activities that you don't want to make 
			available to other applications should have no intent filters, 
			and you can start them yourself using explicit intents.
		
			◼️ Declaring intent filters 

	● Notes

		○ It's a common mistake to write all your code in an Activity or a Fragment. 
		These UI-based classes should only contain logic that handles UI and operating 
		system interactions. To provide a satisfactory user experience and a more manageable 
		app maintenance experience, it's best to minimize your dependency on them.
			
	??? Explicit and Implicit requests 

***********************************************************
***********************************************************
***********************************************************

Fragments 

***********************************************************
***********************************************************
***********************************************************		

App Manifest (File)
	
***********************************************************
***********************************************************
***********************************************************



Layout 
	● General/Intro/Basics 
	A layout defines the structure for a user interface in your app. 

	● View/ViewGroup 
	All elements in the layout are built using a hierarchy of "View" and "ViewGroup" objects. . A "View" usually 
	draws something the user can see and interact with. A "ViewGroup" is an invisible container that defines the 
	layout structure for "View" and other "ViewGroup" objects. 

***********************************************************
***********************************************************
***********************************************************

● Database (ChatGPT & Android Studio) 
	○ General 
		0. Create a DB folder ✔
		1. Folder Structure 
		2. Add Dependencies
		3a. Entity
		3b. DAO
		3c. Database Class
		4. Main Activity
		5. Layout File (optional??) 

	○ 0) Create db/
		◼️ folder/file location : app/src/main/java/com/example/myapp/db 
			
	○ 1) Add Dependencies 
		◼️ folder/file location : app/build.gradle

	○ 2) Entity 
		◼️ folder/file location : app/src/main/java/com/example/myapp/db/User.kt

------------------------------------------------------------------------------------------------------------
____________________________________________________________________________________________________________
____________________________________________________________________________________________________________

------------------------------------------------------------------------------------------------------------

● Database (Android Studio & ChatGPT)
	○ Setup (app/build.gradle)
	To use Room in your app, add the following dependencies to your app's build.gradle file.

	code 

	dependencies {
    val room_version = "2.8.0"
	...
	}

	○ Primary components 

		◼️ General 
			There are three major components in Room : Database class, Data entities, DAO. The database class provides your app with 
			instances of the DAOs associated with that database. In turn, the app can use the DAOs to retrieve data from the database 
			as instances of the associated data entity objects. The app can also use the defined data entities to update rows from the 
			corresponding tables, or to create new rows for insertion. 

		◼️ Database class (app/src/main/java/com/example/myapp/db/AppDatabase.kt)
			The database class that holds the database and serves as the main access point for the underlying connection to 
		    your app's persisted data. 

			code

			@Database(...) 
				... class ... {} 

		◼️ Data entities (app/src/main/java/com/example/myapp/db/User.kt) 
			Data entities that represent tables in your app's database.

			code 

			@Entity 
				data class User(...)




		◼️ DAO (Data Access Objects) (app/src/main/java/com/example/myapp/db/UserDao.kt)
			Data access objects (DAOs) provide methods that your app can use to query, update, 
			insert, and delete data in the database.

			When you use the Room persistence library to store your app's data, you interact 
			with the stored data by defining DAO (Data Access Objects).

			code 

			@Dao
			interface UserDao {...}

			Each DAO includes methods that offer abstract access to your app's database. At c-
			ompile time, Room automatically generates implementations of the DAOs that you define.

				◻️ Define 
				You can define each DAO as either an interface or an abstract class. For basic 
				use cases, you usually use an interface.

				You must always annotate your DAOs with @Dao. DAOs don't have properties, but 
				they do define one or more methods for interacting with the data in your app's 
				database.

				◻️ There are two types of DAO methods that define database interactions :
					◆ Convenience methods - that let you insert, update, and delete rows in 
					your database without writing any SQL code. 
					
					◆ Query methods - that let you write your own SQL query to interact with 
					the database.






	○ Usage

		◼️ After you have defined the data entity, the DAO, and the database object, you can use the following code to create an 
		instance of the database.userDao

		code (app/src/main/java/com/example/myapp/db/AppDatabase.kt)

		val db = Room.databaseBuilder(...).build()
					
		You can then use the abstract methods from the AppDatabase to get an instance of the DAO. In turn, you can use the methods 
		from the DAO instance to interact with the database.
				
		code (app/src/main/java/com/example/myapp/MainActivity.kt)

		val userDao = db.userDao()
		val users: List<User> = userDao.getAll()

	○ Note 
		◼️ If your app runs in a single process, you should follow the singleton design pattern when instantiating an AppDatabase 
		object. Each RoomDatabase instance is fairly expensive, and you rarely need access to multiple instances within a single 
		process. If your app runs in multiple processes, include enableMultiInstanceInvalidation() in your database builder invocation. 

		
				













